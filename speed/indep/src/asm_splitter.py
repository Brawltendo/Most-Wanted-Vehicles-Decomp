# Splits out and sanitizes a function from an asm file generated by MSVC's dumpbin program.

import argparse

# add parser arguments
parser = argparse.ArgumentParser()
parser.add_argument('--i', type=str, required=True, help=
					'The input assembly file.')
parser.add_argument('--addr', type=str, required=True, nargs=2, help=
					'''The start and end addresses (in hex, unprefixed) of the function to be split. 
					Example: --addr 0044FB90 0044FBAF''')
parser.add_argument('--name', type=str, required=True, help=
					'''The output file name without an extension. 
					The suffix '_orig' will be added so it doesn't conflict with the compiler's asm output.''')
#parser.add_argument('--encoding', type=str, required=False, help=
#					'''The source encoding of the asm input. 
#					Use this arg to convert the input to UTF-8 if it's in a different format. 
#					You will likely need to provide this arg as dumpbin's output is not in UTF-8.''')
args = parser.parse_args()

#if args.encoding:
##	with open(os.path.dirname(os.path.realpath(__file__)) + '\\' + args.i, 'r') as f:
##		data = f.read()
##		reEncoded = open(os.path.dirname(os.path.realpath(__file__)) + '\\' + args.i, 'w')
##		reEncoded.write(unicode(data, args.encoding).encode('utf-8'))

with open(args.i, 'r') as inAsm:
	foundStartAddr = False
	linesToFix = []
	for line in inAsm:
		if line:
			# find function start
			if (args.addr[0] + ':') in line:
				foundStartAddr = True
				print('Found function start')

			# add subsequent lines
			if foundStartAddr:
				linesToFix.append(line[:-1])
				# end loop if this line was the end of the function
				if (args.addr[1] + ':') in line:
					print('Found function end')
					break

jmpInsts = [
	'jmp', 
	'jo', 
	'jno', 
	'js', 
	'jns', 
	'je', 'jz', 
	'jne', 'jnz', 
	'jb', 'jnae', 'jc', 
	'jnb', 'jae', 'jnc', 
	'jbe', 'jna', 
	'ja', 'jnbe', 
	'jl','jnge', 
	'jge', 'jnl', 
	'jle', 'jng', 
	'jg', 'jnle', 
	'jp', 'jpe', 
	'jnp', 'jpo', 
	'jcxz', 'jecxz'
]

with open(args.name + '_orig.asm', 'w') as outAsm:
	for line in linesToFix:
		lineLen = len(line)
		origAddr = line[2:10]
		instruction = line[12:24]
		instData = line[24:]
		newAddr = format(int(origAddr, 16) - int(args.addr[0], 16), '08X')

		# build sanitized string
		newLine = []
		newLine.append('  ' + newAddr + ': ' + instruction)
		hasJmpInst = False

		for inst in jmpInsts:
			if inst in instruction:
				jmpAddr = int(instData, 16)
				# make sure the address is within the function boundaries
				if jmpAddr >= int(args.addr[0], 16) or jmpAddr <= int(args.addr[1], 16):
					newLine.append(format(jmpAddr - int(args.addr[0], 16), '08X'))
					hasJmpInst = True

		if not hasJmpInst:
			newLine.append(instData)

		outAsm.write("".join(newLine) + '\n')