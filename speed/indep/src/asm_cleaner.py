# Sanitizes an obj asm file generated by MSVC's dumpbin program.

import argparse
import os

# add parser arguments
parser = argparse.ArgumentParser()
parser.add_argument('--i', type=str, required=True, help=
					'The input assembly file.')
args = parser.parse_args()

# open the file as utf-16 even though it's cp1251
# this ensures that we can actually read lines properly
with open(os.path.dirname(os.path.realpath(__file__)) + '\\' + args.i, 'r', encoding='utf-16') as inAsm:
	foundFunction = False
	functions = []
	functionLines = []
	for line in inAsm:
		if line:
			# find function start
			# check for all four of these symbols to avoid the chance of this finding a false positive
			if '?' in line and '(' in line and ')' in line and ':' in line and not foundFunction:
				foundFunction = True
				#print('Found function start')

			elif '?' in line and '(' in line and ')' in line and ':' in line and foundFunction:
				#print('Found function end')
				functions.append(functionLines.copy())
				functionLines.clear()
			
			elif line == '\n' and foundFunction:
				#print('Found function end')
				functions.append(functionLines.copy())
				functionLines.clear()
				foundFunction = False

			if foundFunction:
				# don't print padding, though this might need to be changed if a function has a debug break
				if 'int         3' in line:
					continue
				functionLines.append(line[:-1])

jmpInsts = [
	'jmp', 
	'jo', 
	'jno', 
	'js', 
	'jns', 
	'je', 'jz', 
	'jne', 'jnz', 
	'jb', 'jnae', 'jc', 
	'jnb', 'jae', 'jnc', 
	'jbe', 'jna', 
	'ja', 'jnbe', 
	'jl','jnge', 
	'jge', 'jnl', 
	'jle', 'jng', 
	'jg', 'jnle', 
	'jp', 'jpe', 
	'jnp', 'jpo', 
	'jcxz', 'jecxz'
]

with open(os.path.dirname(os.path.realpath(__file__)) + '\\' + args.i, 'w', encoding='utf-16') as outAsm:
	for function in functions:
		if function[1][2:10] == '00000000':
			for line in function:
				outAsm.write(line + '\n')
		
		else:
			outAsm.write(function[0] + '\n')
			baseAddr = int(function[1][2:10], 16)
			endAddr = int(function[len(function) - 1][2:10], 16)
			for line in function[1:]:
				origAddr = line[2:10]
				instruction = line[12:24]
				instData = line[24:]
				newAddr = format(int(origAddr, 16) - baseAddr, '08X')

				# build sanitized string
				newLine = []
				newLine.append('  ' + newAddr + ': ' + instruction)
				hasJmpInst = False

				for inst in jmpInsts:
					# strip whitespace and check for equality to avoid duplicate output
					if inst == instruction.strip():
						jmpAddr = int(instData, 16)
						# make sure the address is within the function boundaries
						if jmpAddr >= baseAddr or jmpAddr <= endAddr:
							newLine.append(format(jmpAddr - baseAddr, '08X'))
							hasJmpInst = True

				if not hasJmpInst:
					newLine.append(instData)

				outAsm.write("".join(newLine) + '\n')

		outAsm.write('\n')
