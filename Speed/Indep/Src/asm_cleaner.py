# Sanitizes an obj asm file generated by MSVC's dumpbin program.

import argparse
import os
import re

# add parser arguments
parser = argparse.ArgumentParser()
parser.add_argument('--i', type=str, required=True, help=
					'The input assembly file.')
parser.add_argument('--cpp', type=str, required=True, help=
					'The input cpp file.')
args = parser.parse_args()

class Tag:
	def __init__(self):
		self.type = ''
		self.data = ''
		self.funcStartLine = 0

with open(args.cpp, 'r') as inCpp:
	lines = inCpp.readlines()
	tag = Tag
	tags = []
	tagId = '// <@>'
	isFindingFuncName = False
	for ind, line in enumerate(lines):
		if line:
			if isFindingFuncName:
				# check to see if this line should have a function name
				# doing it like this means you need to have the function name on the same line as the opening parenthesis
				# it also means that this will fail on anything that overloads the parenthesis operator, oh well
				if '(' in line:
					funcSplit = line.split('(')[0].split(' ')
					# some people like a space before the parenthesis, so check for that
					if funcSplit[len(funcSplit) - 1] == ' ':
						tag.data = funcSplit[len(funcSplit) - 2] + '('
					else:
						tag.data = funcSplit[len(funcSplit) - 1] + '('
				# check for opening brace and get the line number
				# this is what will make it easy to check for the function data later
				elif '{' in line:
					isFindingFuncName = False
					tag.funcStartLine = ind + 1
					tags.append(tag)

			# check for a tag identifier
			elif line.startswith(tagId):
				tag = Tag()
				splitName = line.split(tagId)[1].strip()
				if splitName == 'PRINT_ASM':
					tag.type = splitName
					# PRINT_ASM tag is required to be the final one before the function definition
					# this is because it needs to search for the function name
					isFindingFuncName = True

# open the file as utf-16 even though it's cp1251
# this ensures that we can actually read lines properly
with open(args.i, 'r', encoding='utf-16') as inAsm:
	lines = inAsm.readlines()
	mangledNames = []
	# do first pass to find all tagged functions
	if len(tags) > 0:
		for ind, line in enumerate(lines):
			if line.startswith(' Symbol name = '):
				splitLine = line.split(' Symbol name = ')[1]
				for t in tags:
					if t.data in splitLine:
						# check for valid int value
						numIsValid = True
						try:
							lineNum = int(lines[ind - 1].split('Base line number:')[1].strip())
						except:
							numIsValid = False
						if numIsValid and t.funcStartLine == lineNum:
							mangledNames.append(splitLine[:-1] + ':\n')
						break

	foundFunction = False
	functions = []
	functionLines = []
	# do second pass to get all function code
	# if no mangled names are available (means no tags were found), grab every function
	for line in lines:
		if line:
			isTaggedName = len(mangledNames) > 0
			hasSymbolSpecs = line.startswith('?') or line.startswith('_')
			# find function start
			if ((isTaggedName and mangledNames.count(line)) or (not isTaggedName and hasSymbolSpecs)) and not foundFunction:
				foundFunction = True
				#print('Found function start')

			# check for underscores in case of any C functions
			# yes I know they're not mangled but I'm retrofitting this into what I already wrote lol
			elif hasSymbolSpecs and foundFunction:
				#print('Found function end')
				functions.append(functionLines.copy())
				functionLines.clear()
				if isTaggedName and not mangledNames.count(line):
					foundFunction = False

			elif line == '\n' and foundFunction:
				#print('Found function end')
				functions.append(functionLines.copy())
				functionLines.clear()
				foundFunction = False

			shouldPrint = True
			if foundFunction:
				# don't print padding, though this might need to be changed if a function has a debug break
				# don't print generated jumptable labels
				if 'int         3' in line or line.startswith('$'):
					shouldPrint = False
				if shouldPrint:
					functionLines.append(line[:-1])

jmpInsts = [
	'jmp', 
	'jo', 
	'jno', 
	'js', 
	'jns', 
	'je', 'jz', 
	'jne', 'jnz', 
	'jb', 'jnae', 'jc', 
	'jnb', 'jae', 'jnc', 
	'jbe', 'jna', 
	'ja', 'jnbe', 
	'jl','jnge', 
	'jge', 'jnl', 
	'jle', 'jng', 
	'jg', 'jnle', 
	'jp', 'jpe', 
	'jnp', 'jpo', 
	'jcxz', 'jecxz'
]

with open(args.i, 'w', encoding='utf-16') as outAsm:
	for function in functions:
		if function[1][2:10] == '00000000':
			for line in function:
				outAsm.write(line + '\n')
		
		else:
			outAsm.write(function[0] + '\n')
			baseAddr = int(function[1][2:10], 16)
			endAddr = int(function[len(function) - 1][2:10], 16)
			for line in function[1:]:
				origAddr = line[2:10]
				instruction = line[12:24]
				instData = line[24:]
				newAddr = format(int(origAddr, 16) - baseAddr, '08X')

				# build sanitized string
				newLine = []
				newLine.append('  ' + newAddr + ': ' + instruction)
				hasJmpInst = False

				for inst in jmpInsts:
					jmpAddr = 0
					# strip whitespace and check for equality to avoid duplicate output
					if inst == instruction.strip():
						# check for valid int value
						numIsValid = True
						try:
							jmpAddr = int(instData, 16)
						except:
							numIsValid = False
						# make sure the address is within the function boundaries
						if (jmpAddr >= baseAddr or jmpAddr <= endAddr) and numIsValid:
							newLine.append(format(jmpAddr - baseAddr, '08X'))
							hasJmpInst = True

				if not hasJmpInst:
					newLine.append(instData)

				outAsm.write("".join(newLine) + '\n')

		outAsm.write('\n')